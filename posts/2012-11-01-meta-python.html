<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
        <title>meta-python</title>
        <link rel="stylesheet" type="text/css" href="../css/syntax.css"></link>
        <link rel="stylesheet" type="text/css" href="../css/base.css"></link></head>

    <body>
        <div id="navbar">
            <ul>
<li><a href="../index.html">home</a></li>
<li><a href="../projects.html">projects</a></li>
<li><a href="../posts.html">ramblings</a></li>
<li><a href="../about.html">about</a></li>
</ul></div>

        <div id="content">
        <h1>meta-python</h1>

<p>by <em>Mike</em> on <strong>2012-11-01</strong></p>

<p>One of the great things about Python is its meta-programming facilities. I quite enjoy abusing language features that I like, and this post describes two such examples I’ve grown fond of. While their place in production code might be questionable, I have found them quite handy in various quick scripts.</p>
<p>I will present two examples, both of which rely on decorators<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. The first example provides a way to automatically <a href="https://en.wikipedia.org/wiki/Memoization">memoize</a> the results of a function. Assuming the function has no side-effects, calling it with the same argument list should produce the same result, thus saving computation time at the expense of space. Such a decorator can be defined as follows:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">class</span> Memoized(<span class="dt">object</span>):<br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, function):<br />        <span class="ot">self</span>.function = function<br />        <span class="ot">self</span>.mem = {}<br />    <span class="kw">def</span> <span class="ot">__call__</span>(<span class="ot">self</span>, *args, **kwargs):<br />        key = args, <span class="dt">tuple</span>(kwargs.iteritems())<br />        <span class="kw">if</span> key in <span class="ot">self</span>.mem:<br />            <span class="kw">return</span> <span class="ot">self</span>.mem[key]<br />        value = <span class="ot">self</span>.function(*args, **kwargs)<br />        <span class="ot">self</span>.mem[key] = value<br />        <span class="kw">return</span> value</code></pre>
<p>Note that the above code never deletes stored values, which can lead to long running programs running out of memory.</p>
<p>Now it is very simple to use memoization without modifying a function, by merely adding the decorator before its definition (even if the source code is not available, any function object can be wrapped in this class at runtime). The following example converts a function which counts the number of times a word appears in a document to the memoized equivalent:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ot">@Memoized</span><br /><span class="kw">def</span> occurences(word, words):<br />    <span class="kw">return</span> <span class="dt">sum</span>(w == word <span class="kw">for</span> w in words)</code></pre>
<p>The second example stems from my fascination with the Python <code>yield</code> statement. Quite often I find myself writing small functions which need to return a materialised sequence (e.g. a list or dictionary), but not small enough to nicely fit into say, a list comprehension. To avoid the tedious boilerplate of initializing the sequence, appending elements to it, and then returning the result, I’ve resorted to the following scheme: I use a composition decorator, which takes the type of sequence as argument, and applies it to the result of a generator function.</p>
<p>The end result, slightly generalised, is the following:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> compose(f1, f2):<br />    <span class="kw">assert</span> <span class="dt">callable</span>(f1) and <span class="dt">callable</span>(f2)<br />    <span class="kw">def</span> composition(*args, **kwargs):<br />        <span class="kw">return</span> f1(f2(*args, **kwargs))<br />    <span class="kw">return</span> composition<br /><br /><span class="kw">class</span> Compose(<span class="dt">object</span>):<br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, *functions):<br />        <span class="ot">self</span>.functions = functions<br />    <span class="kw">def</span> <span class="ot">__call__</span>(<span class="ot">self</span>, function):<br />        <span class="kw">return</span> <span class="dt">reduce</span>(compose, <span class="ot">self</span>.functions + (function,))</code></pre>
<p>And here is how it could be used on a higher order function which applies arbitrary user functions to dictionary keys and/or values:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> identity(x): <span class="kw">return</span> x<br /><br /><span class="co"># Original</span><br /><span class="kw">def</span> dmap1(d, keys=identity, values=identity):<br />    <span class="kw">return</span> <span class="dt">dict</span>((keys(key), values(value)) <span class="kw">for</span> key, value in d.iteritems())<br /><br /><span class="co"># Amended</span><br /><span class="ot">@Compose</span>(<span class="dt">dict</span>)<br /><span class="kw">def</span> dmap2(d, keys=identity, values=identity):<br />    <span class="kw">for</span> key, value in d.iteritems():<br />        <span class="kw">yield</span> keys(key), values(value)</code></pre>
<p>The previous example was hardly an improvement in terms of code size, but some more elaborate examples are hopefully more motivating:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ot">@Compose</span>(<span class="dt">tuple</span>)<br /><span class="kw">def</span> take(n, items):<br />    <span class="kw">assert</span> n &gt;= <span class="dv">0</span><br />    <span class="kw">for</span> i, item in <span class="dt">enumerate</span>(items):<br />        <span class="kw">if</span> i &gt;= n:<br />            <span class="kw">break</span><br />        <span class="kw">yield</span> item<br /><br /><span class="ot">@Compose</span>(<span class="dt">set</span>)<br /><span class="kw">def</span> words_of(dictionary):<br />    <span class="co">&quot;&quot;&quot;Return the set of words in a hunspell dictionary file.&quot;&quot;&quot;</span><br />    <span class="kw">with</span> <span class="dt">open</span>(dictionary) <span class="ch">as</span> f:<br />        f.readline() <span class="co"># Skip word count</span><br />        <span class="kw">for</span> line in f:<br />            <span class="kw">yield</span> line.split()[<span class="dv">0</span>].split(<span class="st">'/'</span>)[<span class="dv">0</span>].lower()</code></pre>
<p>The composition decorator is quite general, and can be applied to different scenarios as well. In addition, multiple decorators can be chained together. For example, to produce a <em>sorted</em> sequence of <em>unique</em> tokens in a collection of documents, one could write the following:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ch">import</span> re<br /><br /><span class="kw">def</span> tokenize(data):<br />    <span class="kw">for</span> token in re.split(<span class="st">'[\s:;!?-]+'</span>, data):<br />        token = token.lower().strip(<span class="st">&quot;&quot;&quot;()[]{},.&quot;'&quot;&quot;&quot;</span>)<br />        <span class="kw">if</span> token:<br />            <span class="kw">yield</span> token<br /><br /><span class="ot">@Compose</span>(<span class="dt">sorted</span>, <span class="dt">set</span>)<br /><span class="kw">def</span> all_words(documents):<br />    <span class="co">&quot;&quot;&quot;Retrieve the set of unique words in a document, after tokenization.&quot;&quot;&quot;</span><br />    <span class="kw">for</span> document in documents.itervalues():<br />        <span class="kw">for</span> word in tokenize(document):<br />            <span class="kw">yield</span> word</code></pre>
<p>Using decorators in this manner has proven quite helpful in prototypes and rapidly changing code.</p>
<div class="footnotes">
<hr></hr>
<ol>
<li id="fn1"><p>For a nice introduction to decorators, I recommend the series of tutorials by Bruce Eckel (<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">1</a>, <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240845">2</a>, <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=241209">3</a>). <a href="#fnref1" class="footnoteBackLink">↩</a></p></li>
</ol>
</div>


        <div id="powered">
        <fieldset><legend>Powered by</legend>
            <ul>
                <li><a href="http://www.gnu.org">Free Software</a></li>
                <li><a href="http://www.vim.org">Vim</a></li>
                <li><a href="http://jaspervdj.be/hakyll/">Hakyll</a></li>
                <li><a href="http://johnmacfarlane.net/pandoc/">Pandoc</a></li>
                <li><a href="http://sass-lang.com">Sass</a></li>
            </ul></div></div>

    </body></html>
