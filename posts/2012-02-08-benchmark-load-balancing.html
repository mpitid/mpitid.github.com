<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
        <title>Benchmark Load Balancing</title>
        <link rel="stylesheet" type="text/css" href="../css/base.css"></link></head>

    <body>
        <div id="navbar">
            <ul>
<li><a href="../index.html">home</a></li>
<li><a href="../projects.html">projects</a></li>
<li><a href="../posts.html">ramblings</a></li>
<li><a href="../about.html">about</a></li>
</ul></div>

        <div id="content">
        <h1>Benchmark Load Balancing</h1>

<p>by <em>Mike</em> on <strong>2012-02-08</strong></p>

<h2 id="the-problem">The Problem</h2>
<p>I am always looking for ways to turn boring school assignments to fun projects . A recent one involves the execution of a handful of <a href="http://www.spec.org/cpu2006/">spec</a> benchmarks for a random set of <a href="http://gcc.gnu.org/onlinedocs/gcc-4.4.5/gcc/Optimize-Options.html">gcc flags</a> for my Compiler Optimisation course. This presents a slight challenge as the set of flags times the repetition count for each benchmark adds up to a rather large total execution time. Hence, parallelizing benchmark execution seemed reasonable and a fun-enough challenge.</p>
<p>My initial approach was to load balance the benchmarks on the school’s 16-core <code>compute</code> machine (2 Intel X5550 Quad Cores with HyperThreading). This boiled down to generating the necessary commands —making sure each command is allocated to a specific core with <code>taskset</code>— and piping them to <code>xargs -L 1 -P $(fgrep -c name /proc/cpuinfo)</code>. This approach produced very large deviations however. This was partly because the machine was already under heavy load by other users —so distributing the tasks to individual CPUs instead of cores did not give significantly smaller deviations either.</p>
<p>My next thought was to schedule the benchmarks on regular login machines, most of which sit idly during the night, or even most of the day. Running on diverse hardware is not an issue —as long as a single benchmark is executed on the same machine for all different flag combinations— since I don’t care about relative performance across benchmarks. One problem with this approach however, was that it involved finding <em>properly functioning</em> machines which are unlikely to be used, and noting down their host names.</p>
<h2 id="the-solution">The Solution</h2>
<p>So I kept putting it off, until I became aware of a <a href="http://project.shearn89.com">cool undergraduate project</a>. The project lists all login machines and their availability and could not have come at a more convenient time.</p>
<p>I quickly wrote down a script to scrape the <code>available</code> page and distribute each separate benchmark to one machine.</p>
<p>The <code>distribute</code> script finds available machines and submits a job via ssh. For some reason I could not use <a href="http://www.gnu.org/software/screen/">screen</a> or <a href="http://tmux.sourceforge.net/">tmux</a>, since they would get killed as soon as the ssh session terminated. So I had resort to good old <code>nohup</code>. Furthermore, I opted for <code>zsh</code> on this one since I was fed-up with the annoying idiosyncrasies of bash when it comes to separator handling —I couldn’t get the HOST array to split properly on newlines.</p>
<pre class="sourceCode"><code class="sourceCode bash"><span class="co">#!/bin/zsh</span><br /><span class="co"># Distribute computation across different machines.</span><br /><br /><span class="co"># Parse lines in the following format to retrieve hosts:</span><br /><span class="co"># &lt;span class='label label-success'&gt;bazzini.inf.ed.ac.uk&lt;/span&gt;</span><br /><span class="ot">HOSTS=($(</span><span class="kw">wget</span> -O - http://project.shearn89.com/available <span class="kw">\</span><br />       <span class="kw">|</span> <span class="kw">sed</span> -rn <span class="st">'/label-success/ s/.*&gt;([^&lt;]+)&lt;.*/\1/p'</span><span class="ot">))</span><br /><span class="ot">i=</span>1<br /><span class="kw">for</span> src <span class="kw">in</span> <span class="ot">$@</span>; <span class="kw">do</span><br />    <span class="ot">host=${HOSTS[$((</span> i++ <span class="ot">))]}</span><br />    <span class="kw">ssh</span> -n <span class="ot">$host</span> <span class="st">&quot;nohup ./runjob </span><span class="ot">$src</span><span class="st">&quot;</span> <span class="kw">&amp;</span><br /><span class="kw">done</span></code></pre>
<p>The <code>runjob</code> script simply changes into my project directory and executes the benchmark, while logging some information like which benchmark is matched to which machine.</p>
<pre class="sourceCode"><code class="sourceCode bash"><span class="co">#!/bin/bash</span><br /><br /><span class="ot">src=$(</span><span class="kw">basename</span> <span class="ot">$1)</span><br /><span class="kw">cd</span> msc/copt1<br /><span class="ot">joblog=</span><span class="st">&quot;info.</span><span class="ot">$src</span><span class="st">.</span><span class="ot">$(</span><span class="kw">hostname</span><span class="ot">)</span><span class="st">.log&quot;</span><br /><span class="kw">date</span> +<span class="st">'%F %T'</span> <span class="kw">&gt;&gt;</span> <span class="ot">$joblog</span><br /><span class="kw">cat</span> /proc/cpuinfo  <span class="kw">&gt;&gt;</span> <span class="ot">$joblog</span><br />taskset -c 1 ./benchmark <span class="ot">$@</span><br /><span class="kw">echo</span> <span class="ot">$?</span> <span class="ot">$@</span> <span class="kw">&gt;&gt;</span> <span class="st">&quot;</span><span class="ot">$joblog</span><span class="st">&quot;</span> </code></pre>
<p>The <code>benchmark</code> script is responsible for reading available flags, compiling a benchmark and then executing it for a certain number of iterations. After execution is complete, average runtime and standard deviation are calculated with a simple <a href="http://www.gnu.org/software/gawk/">awk</a> script, <code>stats.awk</code>.</p>
<pre class="sourceCode"><code class="sourceCode bash"><span class="co">#!/bin/bash</span><br /><br /><span class="ot">SRC=</span><span class="st">&quot;</span><span class="ot">$1</span><span class="st">&quot;</span><br /><span class="ot">DST=</span><span class="st">&quot;</span><span class="ot">${2:-$(</span><span class="kw">pwd</span><span class="ot">)</span>/out<span class="ot">}</span><span class="st">&quot;</span><br /><span class="ot">FLAGS=</span><span class="st">&quot;</span><span class="ot">${3:-</span>200-flags<span class="ot">}</span><span class="st">&quot;</span><br /><span class="ot">TIMES=</span><span class="st">&quot;</span><span class="ot">${4:-</span>12<span class="ot">}</span><span class="st">&quot;</span><br /><br /><span class="fu">die()</span> <span class="kw">{</span> <span class="kw">echo</span> <span class="ot">$@</span>; <span class="kw">exit</span> 1; <span class="kw">}</span><br /><br /><span class="kw">[[</span> <span class="ot">-z</span> <span class="st">&quot;</span><span class="ot">$SRC</span><span class="st">&quot;</span><span class="kw"> ]]</span> <span class="kw">&amp;&amp;</span> die <span class="st">&quot;usage: </span><span class="ot">$0</span><span class="st"> src [dst=</span><span class="ot">$DST</span><span class="st">] [flags=</span><span class="ot">$FLAGS</span><span class="st">] [times=</span><span class="ot">$TIMES</span><span class="st">]&quot;</span><br /><br /><span class="ot">name=</span><span class="st">&quot;</span><span class="ot">$(</span><span class="kw">basename</span> <span class="ot">$SRC)</span><span class="st">&quot;</span><br /><span class="ot">dst=</span><span class="st">&quot;</span><span class="ot">$DST</span><span class="st">/</span><span class="ot">$name</span><span class="st">&quot;</span><br /><span class="kw">mkdir</span> -p <span class="st">&quot;</span><span class="ot">$dst</span><span class="st">&quot;</span> <span class="kw">||</span> die <span class="st">&quot;Failed to create output directory </span><span class="ot">$dst</span><span class="st">&quot;</span><br /><br /><span class="ot">log=</span><span class="st">&quot;</span><span class="ot">$dst</span><span class="st">/run.log&quot;</span><br /><span class="ot">buildlog=</span><span class="st">&quot;</span><span class="ot">$dst</span><span class="st">/build.log&quot;</span><br /><br /><span class="ot">f=</span>0<br /><span class="kw">while</span> <span class="kw">read</span> <span class="ot">flags</span>; <span class="kw">do</span><br />    <span class="kw">((</span> f++ <span class="kw">))</span><br />    <span class="ot">file=</span><span class="st">&quot;</span><span class="ot">$(</span><span class="kw">printf</span> <span class="ot">$dst</span>/%03d.times <span class="ot">$f)</span><span class="st">&quot;</span><br />    <span class="ot">run=$(</span><span class="kw">printf</span> <span class="st">&quot;</span><span class="ot">$(</span><span class="kw">basename</span> <span class="ot">$SRC)</span><span class="st"> %03d&quot;</span> <span class="ot">$f)</span><br />    <span class="kw">echo</span> <span class="st">&quot;</span><span class="ot">$(</span><span class="kw">date</span> +<span class="st">'%F %T'</span><span class="ot">)</span><span class="st"> </span><span class="ot">$run</span><span class="st"> </span><span class="ot">$flags</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="kw">tee</span> -a <span class="st">&quot;</span><span class="ot">$log</span><span class="st">&quot;</span> <span class="st">&quot;</span><span class="ot">$buildlog</span><span class="st">&quot;</span><br /><br />    <span class="kw">make</span> -s -C <span class="st">&quot;</span><span class="ot">$SRC</span><span class="st">/src&quot;</span> <span class="ot">CFLAGS=</span><span class="st">&quot;</span><span class="ot">$flags</span><span class="st">&quot;</span> <span class="kw">1&gt;</span>/dev/null <span class="kw">2&gt;&gt;</span><span class="ot">$buildlog</span> <span class="kw">\</span><br />      <span class="kw">||</span> die <span class="st">&quot;Failed to build </span><span class="ot">$SRC</span><span class="st">&quot;</span><br /><br />    <span class="kw">pushd</span> <span class="st">&quot;</span><span class="ot">$SRC</span><span class="st">&quot;</span><br />    <span class="kw">for</span> i <span class="kw">in</span>  <span class="ot">$(</span><span class="kw">seq</span> <span class="ot">$TIMES)</span>; <span class="kw">do</span><br />        /usr/bin/time --output=<span class="st">&quot;</span><span class="ot">$file</span><span class="st">&quot;</span> --append <span class="kw">\</span><br />                      --format=<span class="st">'r %e k %S u %U csi %c csv %w'</span> <span class="kw">\</span><br />                      ./run.sh <span class="kw">1&gt;</span>/dev/null <span class="kw">2&gt;&gt;</span><span class="ot">$log</span><br />    <span class="kw">done</span><br />    <span class="kw">popd</span><br /><br />    <span class="kw">echo</span> -e <span class="st">&quot;</span><span class="ot">$name</span><span class="st">\n</span><span class="ot">$flags</span><span class="st">\n</span><span class="ot">$(</span>./stats.awk <span class="ot">$file)</span><span class="st">&quot;</span> <span class="kw">\</span><br />       <span class="kw">|</span> <span class="kw">tee</span> -a <span class="st">&quot;</span><span class="ot">$dst</span><span class="st">/results.txt&quot;</span> <span class="kw">|</span> <span class="kw">tail</span> -n 1<br /><span class="kw">done</span> <span class="kw">&lt;</span> <span class="ot">$FLAGS</span></code></pre>
<pre class="sourceCode"><code class="sourceCode awk"><span class="co">#!/usr/bin/awk -f</span><br /><br /><span class="st">/^r/</span> <span class="kw">{</span><br />    <span class="co"># Sum kernel/user CPU time and convert to milliseconds.</span><br />    cpu = <span class="dv">1000</span> * (<span class="ot">$4</span> + <span class="ot">$6</span>)<br />    sum += cpu<br />    ssq += cpu * cpu<br />    <span class="kw">printf</span>(<span class="st">&quot;%d &quot;</span>, cpu)<br /><span class="kw">}</span><br /><br /><span class="st">END</span> <span class="kw">{</span><br />    <span class="co"># Print a line with average runtime and standard deviation.</span><br />    avg = sum / <span class="dt">NR</span><br />    var = ssq / <span class="dt">NR</span> - avg * avg<br />    <span class="kw">printf</span>(<span class="st">&quot;\n%.2f %.2f\n&quot;</span>, avg, <span class="fu">sqrt</span>(var))<br /><span class="kw">}</span></code></pre>
<p>There is no need to move files since I am taking advantage of <a href="http://en.wikipedia.org/wiki/Andrew_File_System">AFS</a>, both for the benchmark source and output files. Adding appropriate commands to setup a proper environment on local storage should be trivial however.</p>
<h2 id="future-work">Future Work</h2>
<p>The distribution scripts are a bit rough and assigning jobs to machines randomly is not the best approach. For example, some machines are i3 Quad Cores at 3.0GHz, while others are dated Core 2 Duo at 1.8GHz. It should be relatively straightforward to retrieve the specs of each machine and assign benchmarks to machines with adequate performance and no load —ideally such information should be provided in the original listing though. For example, the following script generates such a list:</p>
<pre class="sourceCode"><code class="sourceCode bash"><span class="co">#!/bin/bash</span><br /><br /><span class="fu">stathosts()</span> <span class="kw">{</span><br />    <span class="kw">while</span> <span class="kw">read</span> <span class="ot">host</span>; <span class="kw">do</span><br />       <span class="kw"> [[</span> <span class="st">&quot;</span><span class="ot">$host</span><span class="st">&quot;</span> <span class="ot">=</span> <span class="st">&quot;Available&quot;</span><span class="kw"> ]]</span> <span class="kw">&amp;&amp;</span> <span class="kw">continue</span><br />        <span class="kw">echo</span> <span class="ot">$host</span><br />        <span class="kw">ssh</span> -nT <span class="ot">$host</span> <span class="st">'fgrep name /proc/cpuinfo; uptime; exit'</span><br />        <span class="kw">echo</span><br />    <span class="kw">done</span><br /><span class="kw">}</span><br /><br /><span class="kw">wget</span> -O - http://project.shearn89.com/available <span class="kw">|</span><span class="kw">\</span><br /><span class="kw">sed</span> -rn <span class="st">'/label-success/ s/.*&gt;([^&lt;]+)&lt;.*/\1/p'</span>  <span class="kw">|</span><span class="kw">\</span><br />stathosts <span class="kw">&gt;</span> <span class="ot">${1:-</span>host.stats<span class="ot">}</span></code></pre>
<p>It is then just a matter of turning this information into a usable heuristic. The benchmarks could be also ranked slowest to fastest with a script like the following:</p>
<pre class="sourceCode"><code class="sourceCode bash"><span class="co">#!/bin/bash</span><br /><br /><span class="kw">for</span> src <span class="kw">in</span> <span class="ot">$@</span>; <span class="kw">do</span><br />    <span class="kw">make</span> -C <span class="ot">$src</span>/src <span class="kw">&amp;&gt;</span>/dev/null<br />    <span class="kw">pushd</span> <span class="ot">$src</span> <span class="kw">&amp;&gt;</span>/dev/null<br />    /usr/bin/time --format=<span class="st">'%e'</span> --output=<span class="kw">&gt;(</span><span class="kw">read</span> <span class="ot">t</span>; <span class="kw">echo</span> <span class="ot">$t</span> <span class="ot">$(</span><span class="kw">basename</span> <span class="ot">$src)</span><span class="kw">)</span> <span class="kw">\</span><br />                  taskset -c 0 ./run.sh <span class="kw">&amp;&gt;</span>/dev/null<br />    <span class="kw">popd</span> <span class="kw">&amp;&gt;</span>/dev/null<br /><span class="kw">done</span> <span class="kw">|</span> <span class="kw">sort</span> -rgk 1 <span class="kw">|</span> <span class="kw">cut</span> -d<span class="st">' '</span> -f 2</code></pre>
<!-- vim: set ft=markdown tw=72: -->




        <div id="powered">
        <fieldset><legend>Powered by</legend>
            <ul>
                <li><a href="http://www.gnu.org">Free Software</a></li>
                <li><a href="http://www.vim.org">Vim</a></li>
                <li><a href="http://jaspervdj.be/hakyll/">Hakyll</a></li>
                <li><a href="http://johnmacfarlane.net/pandoc/">Pandoc</a></li>
                <li><a href="http://sass-lang.com">Sass</a></li>
            </ul></div></div>

    </body></html>
